> **For AI Agents:** This mind map is your primary knowledge index. Read overview nodes [1-5] first, then follow links [N] to find what you need. Always reference node IDs. When you encounter bugs, document your attempts in relevant nodes. When you make changes, update outdated nodes immediatelyâ€”especially overview nodes since they're your springboard. Add new nodes only for genuinely new concepts. Keep it compact (20-50 nodes typical). The mind map wraps every task: consult it, rely on it, update it.

[1] **Orchestration Package Overview** - `scripts/orchestration/` is a portable automation submodule that coordinates two-agent development loops through shared state, deterministic prompt routing, and Git-backed handoffs [2][3][4]. The package intentionally separates policy selection (workflow/router), execution plumbing (runner + agent dispatch), and transport/safety (git bus + autocommit) so each concern can evolve independently [5][9][13][15][16]. Primary entrypoints are `supervisor.py`, `loop.py`, and `orchestrator.py`, with thin shell wrappers for repo-root usage [6][7][8][17]. The operational contract is documented in `README.md`, while behavior is codified by targeted tests under `scripts/orchestration/tests/` [24][25].

[2] **Runtime Topology and Modes** - The runtime has two canonical actors, supervisor (galph) and engineer loop (ralph), and can execute them either as independent processes (`supervisor.py` + `loop.py`) or a single combined process (`orchestrator.py --mode combined`) [6][7][8]. Sync mode uses `sync/state.json` plus git pull/push handoffs for cross-machine coordination, while async/local mode runs iterations back-to-back without mandatory git gating [3][5]. Role mode (`orchestrator.py --mode role`) is a compatibility shim that forwards to role-specific mains while preserving orchestration flags and prompt overrides [6][17]. The topology is workflow-driven rather than actor-hardcoded, so prompt order can switch between standard and cadence variants [4][11].

[3] **State Machine and Handoff Contract** - `state.py` defines `OrchestrationState` with durable fields (`workflow_name`, `step_index`, `iteration`, `expected_step`, `status`, commit SHAs, and `last_prompt`) and atomic file writes to avoid partial corruption [12]. Step parity is the handshake invariant: supervisor acts on even `step_index`, loop on odd, and successful turns call `stamp(increment_step=True)` to advance both `step_index` and `iteration` [7][8][12]. Status transitions follow `idle -> running -> waiting-next/complete` with `failed` as terminal for the current cycle, and both sync runners persist stamped state before publish to make restarts idempotent [5][7][8]. Manual stamping via `stamp_handoff.py` mirrors these semantics for out-of-band recovery or controlled handoff without executing prompts [21].

[4] **Prompt Selection Architecture** - Prompt choice is a two-layer system: deterministic workflow resolution from `(workflow_name, step_index)` and optional router override constrained by allowlist and file existence checks [10][11]. Router modes (`router_default`, `router_first`, `router_only`) are normalized centrally and applied consistently in supervisor, loop, and combined orchestration paths [6][7][8][10]. `runner.select_prompt` and `run_turn` convert route decisions into concrete prompt files while recording `expected_step` and optionally `last_prompt` for traceability [9][12]. Review cadence behavior is encoded as workflow logic, where configured cycles can replace both steps with reviewer prompts [11][24].

[5] **Git Synchronization and Safety Model** - Git operations are wrapped in `git_bus.py` and consumed by supervisor/loop to enforce branch targeting, pull-before-run freshness, stamped-state commits, and explicit `push origin HEAD:<branch>` publication [7][8][16]. Pull handling is defensive: rebase-in-progress abort, rebase-first attempt, non-rebase fallback, and explicit detection of untracked-file overwrite collisions with actionable errors [16]. `--no-git` mode disables all git-side effects while preserving local state progression, enabling offline or bootstrap workflows and receiving dedicated regression tests [7][24]. Auto-commit systems for docs, reports, and tracked outputs run around the handoff path so reproducibility artifacts publish with state progression but still respect path and size guardrails [15].

[6] **Combined Orchestrator Core (`orchestrator.py`)** - `orchestrator.py` adds a higher-level control plane with `run_combined_iteration` executing galph then ralph sequentially, stamping state between turns, and invoking post-turn autocommit hooks [15]. `build_combined_contexts` and `_apply_start_prompt` let combined mode align routing context and jump the state to a desired workflow prompt without violating cycle arithmetic [4][11]. In `--mode role`, it delegates to `supervisor.main()` or `loop.main()` after applying prompt/workflow env forwarding, keeping one CLI surface for both legacy and modern execution styles [2][7][8]. Its failure handling centralizes turn errors into stamped `failed` state with per-step logs under `logs/<branch>/steps/iter-..._step-...` [3][9][25].

[7] **Supervisor Actor (`supervisor.py`)** - Supervisor owns the even-step turn, generates the planning prompt execution, and performs the strictest hygiene checks before handing off [3][5]. It supports router/workflow-driven prompt selection, agent dispatch maps, and sync waiting loops with heartbeat/verbose diagnostics for state polling [4][10][13]. Pre-pull recovery includes optional submodule scrub plus staged auto-commit fallbacks (tracked outputs then doc whitelist) to reduce deadlocks on local dirt while preserving explicit failure on unresolved conflicts [15][16]. Post-run it stamps `waiting-next` on success, or `failed` on non-zero prompt exits/guard violations, and then publishes state commit and push unless `--no-git` disables transport [12][24].

[8] **Engineer Loop Actor (`loop.py`)** - Loop mirrors supervisor mechanics for odd-step execution but focuses on implementation turns and completion stamping semantics (`status=complete` on success) [3][7][12]. It supports both sync-via-git and async modes, including local exit-signal checks from state (`exit`, `exit_reason`) and optional `--allow-dirty` continuation if pull cannot cleanly resolve [5]. Prompt selection and agent resolution reuse the same router/workflow and dispatch primitives as supervisor to keep behavioral parity [4][9][10][13]. After execution it stamps/pushes state first in sync mode for idempotent recovery, then optionally pushes residual local commits in async mode for hygiene [16][21].

[9] **Execution Runner Layer (`runner.py`)** - `runner.py` is the transport-neutral execution substrate providing `tee_run`, router prompt invocation, route-to-file selection, and turn result packaging [4]. `tee_run` streams process output to terminal and log with non-blocking IO, configurable PTY behavior, and idle heartbeat emission (`ORCHESTRATION_PROMPT_HEARTBEAT_SECS`) so long prompts remain observable [23]. PTY policy is agent-aware (`resolve_use_pty` avoids PTY for Claude in auto mode) and can be globally forced with `ORCHESTRATION_PTY_MODE` [13][23]. Because supervisor/loop/orchestrator all depend on this layer, it is the main consistency point for logging semantics and prompt execution behavior [6][7][8].

[10] **Router Module (`router.py`)** - Router logic formalizes deterministic prompt selection (`deterministic_route`), override parsing (`apply_router_override`), and mode composition (`select_prompt_with_mode`) [4][11]. Prompt tokens are normalized to `.md`, allowlists are canonicalized, and paths resolve relative to `prompts_dir` with strict existence checks, so routing failures are explicit rather than silent [14]. CLI entrypoint `python -m scripts.orchestration.router` reads state and emits selected prompt names for integration or debugging pipelines [17]. `RouterDecision` plus `log_router_decision` gives auditable provenance (`source`, `reason`) that tests assert directly [24].

[11] **Workflow Registry (`workflows.py`)** - Workflow behavior is centralized in `get_workflow` and `resolve_step`, defining `standard`, `standard2`, `review_cadence`, and `review_cadence2` as small immutable step registries [4][10]. Review cadence transforms whole cycles by returning reviewer prompts for both steps when `(cycle_index + 1) % review_every_n_cycles == 0`, which is key for parity across combined and split runners [2][24]. Keeping this in a dedicated module prevents prompt-order logic from drifting across supervisor, loop, and orchestrator implementations [6][7][8]. New workflow variants should be added here first, then wired through config and tests [14][24].

[12] **State Persistence (`state.py`)** - `OrchestrationState.read()` is tolerant: if state is missing/corrupt it returns defaults, and it reconciles legacy `iteration`-only payloads by deriving `step_index` when needed [3]. `write()` uses temp-file + `os.replace` atomic persistence, reducing torn writes under concurrent polling or abrupt process exits [7][8]. `stamp()` centralizes mutation of prompt expectation, status, step increments, commit SHAs, and lease timestamps so actors do not duplicate fragile timestamp/update logic [21]. The model also stores `last_prompt` for router-enabled observability and combined-mode parity behavior [4][10].

[13] **Agent Dispatch and CLI Resolution (`agent_dispatch.py`)** - Agent selection is precedence-driven: CLI prompt map, CLI role map, YAML prompt map, YAML role map, then default agent [14]. Role keys normalize aliases (`galph` -> `supervisor`, `ralph` -> `loop`) and prompt keys normalize relative/absolute forms to ensure map matches are stable across callers [6][7][8]. Command resolution supports Claude and Codex with stream-control flags, buffering wrappers (`PYTHONUNBUFFERED`, `stdbuf`), JSON modes, and optional session persistence toggles [23]. `select_agent_cmd` returns both chosen agent and final command vector, which callers log for traceability before execution [9][24].

[14] **Configuration Loader (`config.py`)** - `load_config` searches upward for `orchestration.yaml`, merges YAML over defaults in `OrchConfig`, and preserves sensible operation when config is missing or `pyyaml` is unavailable [1][2]. It supports both top-level and nested `workflow`, `router`, and `agent` sections, with back-compat inheritance from `router.review_every_n` when explicit workflow cadence is absent [10][11][13]. The file also defines `SpecBootstrapConfig` and shard discovery (`templates/specs/*.md` fallback to `templates/docs/spec-shards/*.md`) used by bootstrap scripts [18][19]. Helper locators (`stream_runner_script`, `stream_to_text_script`, `claude_cli_default`) decouple path resolution from callers [23].

[15] **Auto-Commit Framework (`autocommit.py`)** - Auto-commit features are split by intent: `autocommit_docs`, `autocommit_reports`, and `autocommit_tracked_outputs`, each filtering files by glob, extension, and size budgets before staging/commit [5]. Doc auto-commit enforces a whitelist and returns forbidden paths so supervisor can block handoff when out-of-policy dirt remains unless tolerance flags permit continuation [7]. Report and tracked-output modes support capped artifact publication, optional force-add behavior for ignored files, and dry-run diagnostics used by combined and actor-specific flows [6][8]. Submodule/gitlink filtering prevents accidental staging of nested submodule paths as regular files [16].

[16] **Git Bus (`git_bus.py`)** - `git_bus.py` wraps subprocess git commands with small, reusable helpers (`safe_pull`, `push_with_rebase`, `assert_on_branch`, `has_unpushed_commits`) to keep orchestration logic declarative [5][7][8]. `safe_pull` explicitly handles rebase leftovers and untracked overwrite hazards, returning boolean status while emitting actionable log text for callers [21]. Push helpers use explicit branch refspecs and one retry-after-pull path to reduce manual intervention during sync contention [3]. Because all actors depend on these primitives, regressions here affect every mode and should be validated through no-git and sync-path tests [24].

[17] **Shell Entry Wrappers (`*.sh`)** - `orchestrator.sh`, `supervisor.sh`, `loop.sh`, and `router.sh` are thin launchers that normalize working directory and execute `python -m scripts.orchestration.<module>` from project root [2]. These wrappers preserve a stable CLI contract for users and automation while keeping implementation in Python modules [6][7][8][10]. They also align with the project interpreter policy by calling PATH `python` rather than repo-specific wrappers [1]. Wrapper simplicity is deliberate: behavior changes belong in Python modules and tests, not shell branching [24].

[18] **Project Bootstrap Script (`init_project.sh`)** - `init_project.sh` scaffolds repo docs/plans/specs/sync layout from a template tree (`$PROJECT_TEMPLATES_DIR` or `~/Documents/project-templates`) with `--dry-run`, `--force`, and optional `--spec-bootstrap` state initialization [14]. It creates canonical directories (`docs/`, `specs/`, `plans/templates/`, `sync/`) and copies root docs plus architecture/debug/development templates without touching implementation code or prompts [1][19]. The script documents next-step onboarding, nudging interactive prompt-driven initialization after scaffolding [2]. It is a migration helper for onboarding repos to this orchestration style rather than a per-iteration runtime dependency [25].

[19] **Spec Bootstrap Script (`init_spec_bootstrap.sh`)** - `init_spec_bootstrap.sh` focuses on spec extraction setup by creating `specs/`, `prompts/`, `docs/`, and `sync/spec_bootstrap_state.json`, with `--reset` for state reinitialization [14][18]. It discovers shards from `templates/specs` with legacy fallback and copies `docs/index.md`/`docs/findings.md` when absent to keep documentation minimums intact [1]. The initialized state includes scoring and inventory fields consumed by spec reviewer/writer workflows in downstream automation [20]. This script is intentionally narrower than full project bootstrap, enabling incremental adoption in existing repositories [18].

[20] **Policy Utility Scripts (`focus_check.py`, `check_input.py`, `plan_lint.py`)** - These lightweight CLIs enforce process guardrails before expensive loops run: artifact existence assumptions, required "Findings Applied" evidence in `input.md`, and persistent-plan linkage when inline checklists exceed thresholds [1][19]. They are intentionally simple and best-effort rather than full markdown parsers, favoring quick preflight failures over complex static analysis [7]. `check_input.py` and `plan_lint.py` read defaults from orchestration config paths, so policy stays relocatable across repos [14]. These tools encode operational discipline directly in executable checks rather than relying only on human prompt compliance [24].

[21] **Manual State Stamper (`stamp_handoff.py`)** - `stamp_handoff.py` writes stamped `sync/state.json` updates and associated commits without running prompt execution, useful for controlled recovery and manual progression [3][12]. It enforces optional branch checks, optional pull/push behavior, and dirty-tree guards unless `--allow-dirty` is provided [5][16]. Stamp semantics mirror actor behavior: galph success sets `waiting-next` with increment, ralph success sets `complete` with increment, and both failure paths preserve current step with `failed` status [7][8]. This script is a safety valve for orchestration deadlocks or externalized work completion [2].

[22] **Log Interleaving Utility (`tail_interleave_logs.py`)** - `tail_interleave_logs.py` emits XML-like interleaved output for galph/ralph logs or summaries by iteration, optionally annotating post-state commits and per-commit `ls-tree` snapshots of selected roots [25]. It supports range filters, role filters, source switching (`logs` vs `summaries`), and bounded tail selection to make loop debugging auditable in one artifact [7][8]. The parser still targets legacy galph/ralph directory conventions and SYNC commit subject formats, so it is explicitly documented as partially legacy relative to step-based logging [1]. This utility is observability-oriented and does not affect core state transitions [3][9].

[23] **Claude Stream Adapters (`claude_stream_runner.py`, `claude_stream_to_text.py`)** - Stream adapters normalize Claude stream-json into orchestration-friendly text streaming and deterministic shutdown behavior [9][13]. `claude_stream_runner.py` forces `--output-format stream-json`, forwards stderr in a background thread, prints delta text events, and terminates on `message_stop/response_stop` or engineer-summary file update fallback (`ORCHESTRATION_ENGINEER_SUMMARY_PATH`) [24]. `claude_stream_to_text.py` is a simpler stdin filter for converting stream-json event lines into plain text while preserving non-JSON passthrough [14]. These adapters exist to keep prompt UX responsive and to avoid stuck sessions under streamed protocols [6].

[24] **Test Suite Coverage (`scripts/orchestration/tests/`)** - Tests assert routing semantics, workflow cadence, combined orchestrator behavior, agent dispatch precedence, state defaults, no-git supervisor guarantees, and Claude stream-runner fallback termination [4][5][6][7][8][10][11][13][23]. Notable stress points include router mode enforcement, autocommit plumbing/dry-run behavior, start-prompt state alignment, and role-mode argument guards in orchestrator tests [6]. Coverage is strongest around orchestrator/router contracts and weaker on end-to-end git integration side effects, so high-risk git-bus changes still need manual integration verification [16]. The tests form the executable contract for future refactors and are a required update target when changing any orchestration semantics [1][25].

[25] **Development History and Evolution (Submodule Timeline)** - The orchestration submodule spans 45 commits from `f9657a0` (2025-12-15, initial portable supervisor/loop foundation) to `cfca491` (2026-01-28, start-prompt control), totaling roughly 8,959 insertions and 1,705 deletions across 148 file-change events [1][6]. Early commits established wrappers, no-git mode, output streaming fixes, and bootstrap tooling (`6032832`, `7c4a3d9`, `1567999`, `fbccc94`) [17][18]. Mid-phase expansion on 2026-01-19/20 introduced router modes, combined orchestration, per-role dispatch, autocommit framework, review cadence parity tests, and hardened supervisor no-git behavior (`e3a89df`, `75bc7da`, `42d90c8`, `f126b4a`, `de7dc26`) [5][10][13][15][24]. Late-phase 2026-01-28 refactored workflow-first routing, added standard2/review_cadence2, tuned PTY/stream-json behavior, and added Claude message_stop + engineer_summary fallbacks (`09f2f00`, `8b07ff9`, `baef092`, `89ca312`) [9][11][23], shifting the package from role-script glue to a workflow-centric orchestration framework [2][3][4].
